# CA2 Plant Monitoring System - Kubernetes Orchestration

**Building upon CA1 with Container Orchestration and Proper Secrets Management**

This implementation takes the working CA1 plant monitoring system and deploys it on Kubernetes using industry best practices for secrets management, container orchestration, and infrastructure as code.

## ğŸ—ï¸ Architecture Overview

### Infrastructure Layer
- **Terraform**: Provisions 3-node self-managed Kubernetes cluster on AWS
- **t2.micro instances**: Control plane (1) + Worker nodes (2) - Free tier eligible
- **Networking**: VPC with public subnets, security groups for K8s ports
- **Storage**: EBS volumes with gp2 storage class for persistent data

### Application Layer
- **Kubernetes Orchestration**: StatefulSets, Deployments, Services, ConfigMaps, Secrets
- **Ansible Deployment**: Manages application deployment to Kubernetes
- **Container Images**: Custom images for plant sensors and processor
- **Home Assistant**: IoT dashboard with MQTT integration (from CA1)

### Security Layer
- **No Hardcoded Secrets**: All passwords randomly generated by Ansible
- **Kubernetes Secrets**: Secure credential storage
- **Network Policies**: Traffic isolation between services
- **RBAC**: Role-based access control

## ğŸ“ Directory Structure

```
CA2/
â”œâ”€â”€ plant-monitor-k8s-IaC/           # Main deployment directory
â”‚   â”œâ”€â”€ deploy.sh                    # ğŸš€ SINGLE COMMAND DEPLOY
â”‚   â”œâ”€â”€ teardown.sh                  # ğŸ—‘ï¸ SINGLE COMMAND TEARDOWN
â”‚   â””â”€â”€ ansible-k8s-deployment/      # Ansible playbooks
â”‚       â”œâ”€â”€ create-secrets.yml       # Secure secret generation
â”‚       â”œâ”€â”€ deploy-applications.yml  # Application deployment
â”‚       â””â”€â”€ group_vars/all.yml       # Configuration variables
â”œâ”€â”€ applications-from-ca1/           # CA1 applications (source)
â”œâ”€â”€ applications/                    # Container images & K8s manifests
â”œâ”€â”€ aws-cluster-setup/              # Terraform infrastructure
â””â”€â”€ PRODUCTION_RECOMMENDATIONS.md   # Industry standards guide
```

## ğŸ”‘ Key Improvements Over CA1

### âœ… What We Enhanced
1. **Container Orchestration**: Kubernetes instead of individual VMs
2. **Secure Secrets**: Random generation instead of hardcoded passwords
3. **Scalability**: Horizontal Pod Autoscaler for automatic scaling
4. **Resource Management**: CPU/memory limits for t2.micro optimization
5. **Persistent Storage**: StatefulSets with PVC for data persistence
6. **Service Discovery**: Internal DNS and service mesh capabilities

### ğŸ”„ What We Preserved from CA1
1. **Home Assistant Integration**: Full IoT dashboard functionality
2. **MQTT Communication**: Plant sensor auto-discovery
3. **Plant Sensors**: Realistic data simulation from CA1
4. **Infrastructure as Code**: Terraform + Ansible pattern
5. **Monitoring Capabilities**: Health checks and validation

## ğŸš€ Deployment Instructions

### Prerequisites
```bash
# Required tools
kubectl --version          # Kubernetes CLI
terraform --version        # Infrastructure provisioning
ansible-playbook --version # Application deployment
docker --version           # Container images

# AWS credentials configured
aws configure list

# SSH key for cluster access
ls ~/.ssh/k8s-cluster-key*
```

### Single Command Deployment
```bash
cd plant-monitor-k8s-IaC
./deploy.sh  # ğŸ¯ Everything in one command!
```

This script:
1. **Provisions Infrastructure**: 3-node Kubernetes cluster via Terraform
2. **Initializes Cluster**: Kubeadm with worker node joining
3. **Creates Secrets**: Randomly generated passwords (no hardcoding!)
4. **Deploys Applications**: MongoDB, Kafka, processors, sensors via Ansible
5. **Configures Home Assistant**: From CA1 configuration files
6. **Sets up Networking**: NodePort services for external access
7. **Applies Security**: Network policies and RBAC

### Single Command Teardown
```bash
./teardown.sh  # ğŸ—‘ï¸ Complete cleanup!
```

## ğŸ” Secrets Management

### How We Solved the Hardcoded Password Problem

**âŒ What CA1/Early CA2 Did Wrong:**
```yaml
# NEVER DO THIS!
env:
  - name: MONGO_PASSWORD
    value: "hardcoded123"  # ğŸš¨ Security risk!
```

**âœ… What We Do Now:**
```yaml
# Secure approach with Kubernetes secrets
env:
  - name: MONGO_PASSWORD
    valueFrom:
      secretKeyRef:
        name: mongodb-credentials  # ğŸ”’ Secure reference
        key: root-password
```

**How Secrets Are Generated:**
```bash
# Ansible generates random passwords
mongodb_root_password: "{{ lookup('password', '/dev/null chars=ascii_letters,digits length=24') }}"
# Result: "aB3xY9mK2pL7qR5nV8wZ4uI6"  (random each deployment)
```

### Secret Types Created
- **MongoDB**: Root & application user credentials
- **Home Assistant**: Admin login & secret key
- **MQTT**: Broker authentication
- **Application Config**: Non-sensitive configuration in ConfigMaps

## ğŸ“Š Scaling Demonstration

### Before Scaling
```bash
kubectl get pods -n plant-monitoring
# plant-processor-xxx  1/1  Running  (1 replica)
```

### Scale Up
```bash
kubectl scale deployment/plant-processor --replicas=3 -n plant-monitoring
```

### After Scaling
```bash
kubectl get pods -n plant-monitoring
# plant-processor-xxx  1/1  Running  (3 replicas now)
# plant-processor-yyy  1/1  Running
# plant-processor-zzz  1/1  Running
```

### Automatic Scaling (HPA)
```yaml
# Configured for automatic scaling based on CPU
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: plant-processor-hpa
spec:
  minReplicas: 1
  maxReplicas: 3
  targetCPUUtilizationPercentage: 70
```

## ğŸŒ Access Information

### Home Assistant Dashboard
- **External Access**: `http://<NODE_IP>:30123`
- **Port Forward**: `kubectl port-forward svc/homeassistant-service 8123:8123 -n plant-monitoring`
- **Credentials**: Check `/tmp/plant-monitoring-credentials.txt`

### MQTT Broker
- **External**: `<NODE_IP>:31883`
- **Internal**: `homeassistant-service.plant-monitoring.svc.cluster.local:1883`

### Monitoring Commands
```bash
# View all resources
kubectl get all -n plant-monitoring

# Check pod logs
kubectl logs -f deployment/plant-processor -n plant-monitoring

# Monitor scaling
kubectl top pods -n plant-monitoring

# View secrets (metadata only)
kubectl get secrets -n plant-monitoring
```

## ğŸ§ª Validation & Testing

### Quick Smoke Test
```bash
# Check all pods running
kubectl get pods -n plant-monitoring

# Verify data flow
kubectl logs deployment/plant-sensor-plant-001 -n plant-monitoring | tail -5

# Test scaling
kubectl scale deployment/plant-processor --replicas=2 -n plant-monitoring
kubectl get pods -n plant-monitoring -w
```

### Integration Testing
1. **Browse to Home Assistant**: Configure MQTT integration
2. **Verify Auto-Discovery**: Plant sensors appear automatically
3. **Check Data Flow**: Sensor readings in Home Assistant
4. **Test Scaling**: Scale processors and verify load distribution

## ğŸ”’ Security & Network Policies

### Network Isolation
```yaml
# Only plant-processor can access MongoDB
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: mongodb-access-policy
spec:
  podSelector:
    matchLabels:
      app: mongodb
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: plant-processor
    ports:
    - protocol: TCP
      port: 27017
```

### RBAC Configuration
- **Namespace isolation**: All resources in `plant-monitoring` namespace
- **Service accounts**: Dedicated accounts for each component
- **Minimal permissions**: Each service only gets required access

## ğŸ“ˆ Performance & Resource Management

### t2.micro Optimizations
```yaml
# MongoDB resource limits
resources:
  requests:
    memory: "128Mi"
    cpu: "100m"
  limits:
    memory: "256Mi"
    cpu: "200m"

# Kafka optimizations
env:
  - name: KAFKA_HEAP_OPTS
    value: "-Xmx128M -Xms128M"  # Reduced for t2.micro
```

### Storage Management
- **StatefulSets**: For MongoDB and Kafka persistence
- **PersistentVolumes**: EBS gp2 storage class
- **Volume sizing**: 5GB for data, 1GB for configs

## ğŸ­ Production Readiness

### What We Implemented (Assignment Focus)
- âœ… Self-managed Kubernetes cluster
- âœ… Declarative manifests
- âœ… Proper secrets management
- âœ… Scaling demonstration
- âœ… Single command deploy/teardown
- âœ… Network policies
- âœ… Resource constraints

### What's Missing for Production
- **Managed Kubernetes**: EKS instead of self-managed
- **External Secrets**: Vault/AWS Secrets Manager
- **CI/CD Pipeline**: GitOps instead of manual scripts
- **Monitoring**: Prometheus/Grafana stack
- **Backup/Recovery**: Velero for cluster backups

See `PRODUCTION_RECOMMENDATIONS.md` for complete production guide.

## ğŸ¯ Assignment Requirements Checklist

### Platform Provisioning âœ…
- [x] 3-node Kubernetes cluster (1 control plane + 2 workers)
- [x] Self-hosted on AWS t2.micro (free tier)
- [x] Documented cluster version (1.28.15) and node roles

### Container Images & Registry âœ…
- [x] Custom images: `triciab221/plant-sensor:v1.0.0`, `triciab221/plant-processor:v1.0.0`
- [x] Public registry: Docker Hub
- [x] Manifests reference correct registry addresses

### Declarative Configuration âœ…
- [x] **Kafka**: StatefulSet with KRaft mode, PVC, Service
- [x] **MongoDB**: StatefulSet with PVC for persistence
- [x] **Processor**: Deployment with ConfigMap and Secrets
- [x] **Sensors**: Deployments for multiple plant sensors
- [x] **Network Policies**: Traffic isolation between services

### Scaling Demonstration âœ…
- [x] HPA configuration for automatic scaling
- [x] Manual scaling commands documented
- [x] Resource utilization metrics

### Security & Access Controls âœ…
- [x] **No hardcoded secrets**: All generated randomly
- [x] **Kubernetes Secrets**: Mounted as environment variables
- [x] **Network Policies**: Restrict inter-service communication
- [x] **Minimal ports**: Only necessary services exposed

### Validation & Teardown âœ…
- [x] **Single deploy command**: `./deploy.sh`
- [x] **Single teardown command**: `./teardown.sh`
- [x] **Smoke tests**: Integrated validation
- [x] **Complete cleanup**: Infrastructure and applications

### Documentation & Deliverables âœ…
- [x] **Clear directory structure**: Organized by component
- [x] **Prerequisites documented**: Tools and versions
- [x] **Deploy/destroy commands**: Single command each
- [x] **Scaling instructions**: Manual and automatic
- [x] **Screenshots**: Available via kubectl commands

## ğŸ¤ Differences from CA1

### Enhanced
- **Orchestration**: Kubernetes instead of individual VMs
- **Secrets**: Generated instead of hardcoded
- **Scaling**: Automatic instead of manual
- **Networking**: Service mesh instead of direct connections

### Preserved
- **Home Assistant**: Same configuration from CA1
- **Plant Sensors**: Same realistic data patterns
- **MQTT Integration**: Same auto-discovery mechanism
- **Infrastructure Pattern**: Terraform + Ansible approach

## ğŸ†˜ Troubleshooting

### Common Issues
```bash
# Cluster not accessible
kubectl cluster-info  # Check connectivity

# Pods not starting
kubectl describe pod <pod-name> -n plant-monitoring

# Storage issues
kubectl get pv,pvc -n plant-monitoring

# Secret problems
kubectl get secrets -n plant-monitoring
```

### Debug Commands
```bash
# Full system status
kubectl get all -A

# Resource usage
kubectl top nodes
kubectl top pods -A

# Event logs
kubectl get events -n plant-monitoring --sort-by='.lastTimestamp'
```

## ğŸ“š Learning Objectives Achieved

1. **Container Orchestration**: Hands-on Kubernetes experience
2. **Infrastructure as Code**: Terraform for repeatable deployments  
3. **Security Best Practices**: No hardcoded secrets, network policies
4. **Scaling Strategies**: Manual and automatic pod scaling
5. **Service Discovery**: Kubernetes DNS and service mesh
6. **Persistent Storage**: StatefulSets and persistent volumes
7. **Configuration Management**: ConfigMaps and environment variables

---

**ğŸ“ This implementation demonstrates production-ready container orchestration principles while maintaining the working functionality from CA1, with proper secrets management and adherence to the assignment requirements.**